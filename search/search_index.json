{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Zauberzeug Field Friend is an autonomous, mobile, and AI-driven agricultural robot developed by Zauberzeug GmbH. The robot is specifically designed for autonomous actions, combining lightness, flexibility, and robustness to efficiently handle a variety of outdoor tasks. Equipped with advanced sensor technologies and camera systems, the Field Friend can precisely determine its position, follow crop lines and detect various kinds of plants. With it's modular design, the Field Friend can be extended with various tools and sensors to fit the specific needs of the use case.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>The Open Source software encourages you to modify and enhance the behavior and adapt it to your specific needs.</li> <li>The Modular Design allows equipping with tools from Zauberzeug as well as third-party solutions or your own developments.</li> <li>Advanced Sensing and Autonomy-Algorithms allows autonomous navigation and obstacle avoidance.</li> <li>Full control via web interface remote and locally via WiFi.</li> <li>Manual steering with touch-joystick and keyboard or App.</li> <li>A combined camera/motor calibration for real world coordinate system (unit: meters)</li> <li>...</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We're thrilled that you're interested in contributing to the Field Friend source code! Here are some guidelines that will help you get started.</p>"},{"location":"contributing/#reporting-issues","title":"Reporting issues","text":"<p>If you encounter a bug or other issue, the best way to report it is by opening a new issue on our GitHub repository. When creating the issue, please provide a clear and concise description of the problem, including any relevant error messages and code snippets. If possible, include steps to reproduce the issue.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>We follow a Code of Conduct to ensure that everyone who participates in the NiceGUI community feels welcome and safe. By participating, you agree to abide by its terms.</p>"},{"location":"contributing/#contributing-code","title":"Contributing code","text":"<p>We are excited that you want to contribute code to the Field Friend source code. We're always looking for bug fixes, performance improvements, and new features.</p>"},{"location":"contributing/#coding-style-guide","title":"Coding Style Guide","text":""},{"location":"contributing/#formatting","title":"Formatting","text":"<p>We use autopep8 with a 120 character line length to format our code. Before submitting a pull request, please run</p> <pre><code>autopep8 --max-line-length=120 --in-place --recursive .\n</code></pre> <p>on your code to ensure that it meets our formatting guidelines. Alternatively you can use VSCode, open the feldfreund.code-workspace file and install the recommended extensions. Then the formatting rules are applied whenever you save a file.</p> <p>In our point of view, the Black formatter is sometimes a bit too strict. There are cases where one or the other arrangement of, e.g., function arguments is more readable than the other. Then we like the flexibility to either put all arguments on separate lines or only put the lengthy event handler on a second line and leave the other arguments as they are.</p>"},{"location":"contributing/#imports","title":"Imports","text":"<p>We use ruff to automatically sort imports:</p> <pre><code>ruff check . --fix\n</code></pre>"},{"location":"contributing/#single-vs-double-quotes","title":"Single vs Double Quotes","text":"<p>Regarding single or double quotes: PEP 8 doesn't give any recommendation, so we simply chose single quotes and sticked with it. On qwerty keyboards it's a bit easier to type, is visually less cluttered, and it works well for strings containing double quotes from the English language.</p>"},{"location":"contributing/#f-strings","title":"F-Strings","text":"<p>We use f-strings where ever possible because they are generally more readable - once you get used to them. There are only a few places in the code base where performance really matters and f-strings might not be the best choice. These places should be marked with a <code># NOTE: ...</code> comment when diverging from f-string usage.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#formatting_1","title":"Formatting","text":"<p>Because it has numerous benefits we write each sentence in a new line.</p>"},{"location":"contributing/#examples","title":"Examples","text":"<p>Each example should be about one concept. Please try to make them as minimal as possible to show what is needed to get some kind of functionality. We are happy to merge pull requests with new examples which show new concepts, ideas or interesting use cases.</p>"},{"location":"contributing/#pull-requests","title":"Pull requests","text":"<p>To get started, fork the repository on GitHub, clone it somewhere on your filesystem, commit and push your changes, and then open a pull request (PR) with a detailed description of the changes you've made (the PR button is shown on the GitHub website of your forked repository).</p> <p>When submitting a PR, please make sure that the code follows the existing coding style and that all tests are passing. If you're adding a new feature, please include tests that cover the new functionality.</p>"},{"location":"contributing/#thank-you","title":"Thank you!","text":"<p>Thank you for your interest in contributing. We're looking forward to work with you!</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#run-in-simulation","title":"Run in Simulation","text":"<p>We suggest you begin with simulating the Field Friend on your local development machine. The software is meant to run on Linux and Unix systems so if you are using Windows, consider running in a Docker container or virtual machine.</p> <p>The Field Friend requires either Linux or Mac system with Python {{ python_version }} to run. Windows is currently not supported, but may work by using Docker or a virtual machine.</p> <ol> <li> <p>Clone the repository  <code>git clone git@github.com:zauberzeug/feldfreund.git &amp;&amp; cd feldfreund</code></p> </li> <li> <p>Create a file with your environment variables and replace <code>U4</code> with the name of your robot  <code>echo \"ROBOT_ID=U4\" &gt; .env</code></p> </li> </ol> <p>Now you have two options, either you run the code in Docker, like it does on the robot, or you setup your local python environment to run it. Should you face any problems during the setup, please check the troubleshooting page or submit a GitHub issue.</p>"},{"location":"getting_started/#docker-setup-recommended","title":"Docker Setup (recommended)","text":"<ol> <li> <p>Install Docker</p> </li> <li> <p>Build and start the container.  <code>./docker.sh U</code>  Our <code>docker.sh</code> script will automatically use the correct settings for your system.</p> </li> </ol>"},{"location":"getting_started/#local-setup","title":"Local Setup","text":"<ol> <li> <p>Optional: Setup a virtual environment with venv <code>python3 -m venv .venv &amp;&amp; source .venv/bin/activate</code></p> </li> <li> <p>Install the python requirements  <code>python3 -m pip install -r requirements-dev.txt</code></p> </li> <li> <p>Now you can run the program  <code>python3 main.py</code></p> </li> </ol> <p>In both cases, this will open the user interface of a simulated robot in your browser (if not browse to http://localhost/). The simulation will automatically hot reload upon code changes. The Field Friend code is based on RoSys which itself uses NiceGUI, both having a very gentle learning curve and are designed to boost your rapid development and testing.</p>"},{"location":"getting_started/#run-on-real-hardware","title":"Run on Real Hardware","text":"<p>The following instructions will only work if you have a real Zauberzeug Field Friend at your disposal. Contact sales@zauberzeug.com if you are interested in purchasing this robot.</p>"},{"location":"getting_started/#setup","title":"Setup","text":"<ol> <li>Ensure you can login via ssh without providing a password (via <code>ssh-copy-id</code> command)</li> <li>Ensure you have LiveSync installed with  <code>python3 -m pip install livesync</code></li> <li>Ensure the latest version of the docker image is installed on the Field Friend by syncing the code as described below and then running  <code>./docker.sh U</code></li> <li>Optional: ensure the correct docker containers are loaded on startup by running  <code>./docker.sh stopall &amp;&amp; ./docker.sh U &amp;&amp; ./docker.sh install</code> </li> </ol>"},{"location":"getting_started/#deploy-and-change-code","title":"Deploy and Change Code","text":"<ol> <li>Go to your local <code>feldfreund</code> folder and start the LiveSync script:  <code>./sync.py &lt;ssh-host-name-of-field-friend&gt;</code></li> <li>This will deploy your local code to the Field Friend</li> <li>As long as LiveSync is active, all code change are automatically pushed to the machine</li> <li>Any code changes will automatically trigger a hot reload on the Field Friend.</li> </ol>"},{"location":"getting_started/#update-rosys-and-nicegui","title":"Update RoSys and NiceGUI","text":"<p>To utilize personal versions of RoSys and NiceGUI instead of the default ones provided in the docker image, modify the <code>sync.py</code> file by uncommenting the specific folders.</p>"},{"location":"getting_started/#logs","title":"Logs","text":"<p>You can see the current log with</p> <pre><code>./docker.sh l rosys\n</code></pre> <p>The history of logs can be seen with</p> <pre><code>less -r ~/.rosys/debug.log\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This section provides guidance for diagnosing and resolving issues during operation. Begin by checking the robot\u2019s logs for warnings or errors.</p> <p>Live logs can be viewed using <code>docker.sh l rosys</code>, and archived logs are stored on the robot inside the <code>~/.rosys</code> directory. If further detail is required, enable debug-level logging on the RoSys Logging Page that is available at /logging.</p>"},{"location":"troubleshooting/#asyncio-warning","title":"Asyncio Warning","text":"<p>While running RoSys you may see warnings similar to this one:</p> <pre><code>2021-10-31 15:08:04.040 [WARNING] asyncio: Executing &lt;Task pending name='Task-255' coro=&lt;handle_event() running at /usr/local/lib/python3.9/site-packages/justpy/justpy.py:344&gt; wait_for=&lt;_GatheringFuture pending cb=[&lt;TaskWakeupMethWrapper object at 0x7f7001f8e0&gt;()] created at /usr/local/lib/python3.9/asyncio/tasks.py:705&gt; created at /usr/local/lib/python3.9/site-packages/justpy/justpy.py:261&gt; took 0.238 seconds\n</code></pre> <p>This means some coroutine is clogging the event loop for too long. In the above example it is a whopping 238 ms in which no other actor can do anything. This is an eternity when machine communication is expected to happen about every 10 ms. The warning also provides a (not so readable) hint where the time is consumed.</p> <p>The example above is one of the more frequent scenarios. It means some code inside a user interaction event handler (e.g. <code>handle_event()</code> in <code>justpy.py</code>) is blocking. Try to figure out which UI event code is responsible by commenting out parts of your logic and try to reproduce the warning systematically.</p>"},{"location":"troubleshooting/#cairosvg-on-mac","title":"CairoSVG on Mac","text":"<p>If CairoSVG was installed via Homebrew, python sometimes can't find the correct path to run CairoSVG. This will create a symbolic link to make the library accessible.</p> <pre><code>sudo mkdir -p /usr/local/lib &amp;&amp; sudo ln -sf /opt/homebrew/lib/libcairo.2.dylib /usr/local/lib/libcairo.2.dylib\n</code></pre> <p>You can test it with this command:</p> <pre><code>python3 -c \"import cairocffi; import cairosvg; print('Cairo packages successfully imported!')\"\n</code></pre>"},{"location":"troubleshooting/#missing-linux-dependencies-when-running-locally","title":"Missing Linux dependencies when running locally","text":"<p>In case your Linux system is missing dependencies, look at the first lines of the provided Dockerfile to find them.</p>"},{"location":"troubleshooting/#permission-denied-directly-after-startup","title":"Permission denied directly after startup","text":"<p>If you get the <code>[Errno 13] Permission denied</code> error message right after you started <code>main.py</code>, your system is probably blocking the default port 80. Try setting a custom port in your <code>.env</code>-file, like this</p> <pre><code>ROBOT_ID=U4\nPORT=8080\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>api</li> <li>hardware</li> <li>navigation</li> </ul>"},{"location":"reference/feldfreund_devkit/api/","title":"api","text":""},{"location":"reference/feldfreund_devkit/api/#feldfreund_devkit.api.Online","title":"Online","text":"<pre><code>Online()\n</code></pre> <p>API endpoints for checking the robot's online status.</p>"},{"location":"reference/feldfreund_devkit/hardware/","title":"hardware","text":""},{"location":"reference/feldfreund_devkit/hardware/#feldfreund_devkit.hardware.CanOpenMasterHardware","title":"CanOpenMasterHardware","text":"<pre><code>CanOpenMasterHardware(\n    robot_brain: RobotBrain,\n    *,\n    can: CanHardware,\n    name: str = \"master\",\n    sync_interval: int = 5\n)\n</code></pre> <p>               Bases: <code>ModuleHardware</code></p> <p>RoSys module to control the CANOpen master Lizard module.</p>"},{"location":"reference/feldfreund_devkit/hardware/#feldfreund_devkit.hardware.Safety","title":"Safety","text":"<pre><code>Safety(\n    *,\n    wheels: Wheels,\n    estop: EStop,\n    bumper: Bumper | None = None,\n    modules: list[SafetyMixin] | None = None\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>The safety module is a simple example for a representation of real or simulated robot hardware.</p>"},{"location":"reference/feldfreund_devkit/hardware/#feldfreund_devkit.hardware.SafetyHardware","title":"SafetyHardware","text":"<pre><code>SafetyHardware(robot_brain: RobotBrain, **kwargs)\n</code></pre> <p>               Bases: <code>Safety</code>, <code>ModuleHardware</code></p> <p>This module implements safety hardware.</p>"},{"location":"reference/feldfreund_devkit/hardware/#feldfreund_devkit.hardware.StatusControlHardware","title":"StatusControlHardware","text":"<pre><code>StatusControlHardware(\n    robot_brain: RobotBrain,\n    *,\n    expander: ExpanderHardware,\n    rdyp_pin: int = 39,\n    vdp_pin: int = 39\n)\n</code></pre> <p>               Bases: <code>ModuleHardware</code></p> <p>Reads the status of the robot's power distribution.</p>"},{"location":"reference/feldfreund_devkit/hardware/#feldfreund_devkit.hardware.TeltonikaRouter","title":"TeltonikaRouter","text":"<pre><code>TeltonikaRouter(url: str, admin_password: str)\n</code></pre> <p>Implements the api of the builtin Teltonika RUT955 router.</p>"},{"location":"reference/feldfreund_devkit/hardware/#feldfreund_devkit.hardware.TeltonikaRouter.CONNECTION_CHANGED","title":"CONNECTION_CHANGED  <code>instance-attribute</code>","text":"<pre><code>CONNECTION_CHANGED: Event[ConnectionStatus] = Event()\n</code></pre> <p>Emitted when the connection status changes.</p>"},{"location":"reference/feldfreund_devkit/hardware/#events","title":"Events","text":"Name Description CONNECTION_CHANGED: Emitted when the connection status changes."},{"location":"reference/feldfreund_devkit/hardware/#feldfreund_devkit.hardware.TracksHardware","title":"TracksHardware","text":"<pre><code>TracksHardware(\n    config: TracksConfiguration,\n    robot_brain: RobotBrain,\n    estop: EStopHardware,\n    *,\n    can: CanHardware\n)\n</code></pre> <p>               Bases: <code>Wheels</code>, <code>ModuleHardware</code></p> <p>Expands the RoSys wheels hardware to control the field friend's tracked wheels with dual motors.</p>"},{"location":"reference/feldfreund_devkit/navigation/","title":"navigation","text":""},{"location":"reference/feldfreund_devkit/navigation/#feldfreund_devkit.navigation.generate_three_point_turn","title":"generate_three_point_turn","text":"<pre><code>generate_three_point_turn(\n    end_pose_current_row: Pose,\n    start_pose_next_row: Pose,\n    *,\n    radius: float = 1.5,\n    same_row_threshold: float = 0.01\n) -&gt; list[DriveSegment]\n</code></pre> <p>Generates a three-point turn between two poses</p> <p>:param end_pose_current_row: the pose of the end of the current row :param start_pose_next_row: the pose of the start of the next row :param radius: the radius of the turn :param same_row_threshold: the threshold distance between the end of the current row and the start of the next row to consider them to be on the same row :return: a list of drive segments to perform the turn</p>"},{"location":"reference/feldfreund_devkit/navigation/#feldfreund_devkit.navigation.sub_spline","title":"sub_spline","text":"<pre><code>sub_spline(\n    spline: Spline, t_min: float, t_max: float\n) -&gt; Spline\n</code></pre> <p>Creates a new spline from a sub-segment of the given spline</p>"},{"location":"tutorials/imu_calibration/","title":"Imu Calibration","text":"<p>The IMU is not installed in its intended orientation, that is why we have to find the correct values. The standard coordinate frame of our robots is a right-handed one where X is forward, Y is left and Z is upward. The built-in IMUs orientation is X-left, Y-down and Z-backward, therefore a roll rotation of -90\u00b0 and a yaw rotation of 90\u00b0 is needed for a Robot Brain in its default configuration, where the socket connectors show backwards. Older robots like U4 will need an additional yaw rotation of 90\u00b0 afterwards, because their Robot Brains are built in sideways.</p> <p>Here is a short Python script to generate the needed configuration:</p> <pre><code>#!/usr/bin/env python3\nimport numpy as np\nfrom rosys.geometry import Rotation\n\nbase_rotation = Rotation.from_euler(np.deg2rad(-90), 0, np.deg2rad(90))\nprint(f'{base_rotation=}')\n\nroll = np.deg2rad(0.0)\npitch = np.deg2rad(0.0)\ncorrection = Rotation.from_euler(roll, pitch, 0.0)\nprint(f'{correction=}')\n\ncomplete_correction = correction * base_rotation\nprint(f'{complete_correction=}')\n\nprint('\\nCode snippet for your robot\\'s configuration:')\nprint(f'imu=Imu(offset_rotation=Rotation.from_euler({complete_correction.roll:.6f}, {complete_correction.pitch:.6f}, {complete_correction.yaw:.6f}))')\n</code></pre> <p>Steps:</p> <ol> <li>Find the correct base orientation of your IMU.    If your Field Friend has the standard configuration, you can use this as a starting point:    <code>Imu(offset_rotation=Rotation.from_euler(-1.570796, -0.000000, 1.570796))</code></li> <li>Roll and pitch your robot manually to check if the configuration is correct and the axes are correctly rotated.</li> <li>Place your robot on a level surface and check the IMU's current values on the development page</li> <li>Put the shown values for roll and pitch in the script above.    That will generate your final configuration values.    Note, that IMU values have some noise, so your configuration won't be perfect.</li> </ol>"},{"location":"tutorials/odrive_calibration/","title":"ODrive Calibration","text":""},{"location":"tutorials/odrive_calibration/#flashing-odrive","title":"Flashing ODrive","text":"<p>To flash an ODrive it has to be put into DFU Mode. For this there is a switch on the black ODrive board. This switch has to be put into the DFU setting. Following this, the whole board needs to be power cycled (Including RdyP and the battery connection). Then the ODrive needs to be connected to the Robot Brain using a micro-USB cable. Now the command</p> <pre><code>./flash_odrive.sh fw-v5.6-feldfreund/ODriveFirmware.bin\n</code></pre> <p>can be run. This will flash the STM chip with the newest firmware.</p>"},{"location":"tutorials/odrive_calibration/#calibrating-odirve","title":"Calibrating ODirve","text":"<p>To calibrate the ODrives, they have to be in the run mode(switch with DFU and run). The normal Feldfreund Lizard script will interfere with the calibration script. In order to prevent this the <code>calibration.liz</code> needs to be configured. This can be done in the <code>&lt;path_to_fodler&gt;/lizard</code> folder with the command:</p> <pre><code>./configure.py &lt;path_to_file&gt;/calibration.liz &lt;ESP_port&gt;\n</code></pre> <p>If this is failing, make sure there are no other serial connections running to the ESP.</p> <p>Before starting the calibration make sure, that the tracks do not touch the ground and the ODrive is connected to the Robot Brain using the micro-USB cable. Then for the right track run:</p> <pre><code>python3 calibrate_two_motors_r.py\n</code></pre> <p>and for the left track:</p> <pre><code>python3 calibrate_two_motors_l.py\n</code></pre> <p>If the calibration does not work calling it with <code>sudo</code> can help.</p> <p>These scripts will set the motor parameters and start the calibration of the hall sensors.</p> <p>When you are done, don't forget to reconfigure the ESP with your Feldfreund code.</p>"},{"location":"tutorials/odrive_calibration/#further-debugging","title":"Further debugging","text":"<p>Further debugging can be done using the <code>odrivetool</code>. While the ODrive is connected via USB the tool can be started from the command line. For further documentation reference the ODrive documentation.</p>"},{"location":"tutorials/tutorials/","title":"Tutorials","text":"<p>Welcome to the Field Friend tutorials section! Here you'll find step-by-step guides to help you get the most out of your Field Friend robot.</p> <ul> <li>Docker Management - Learn how to use the docker.sh script to manage your Field Friend containers</li> <li>Field Creation - Guide to creating and configuring fields for your robot</li> <li>IMU calibration - How to determine the correct rotation for the ImuConfiguration</li> </ul>"}]}